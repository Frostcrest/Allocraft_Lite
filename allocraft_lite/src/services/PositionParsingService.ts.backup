/**
 * Position Parsing Service
 * 
 * Advanced service for parsing position symbols and extracting wheel-relevant data.
 * Handles various option symbol formats, stock positions, and covered call scenarios.
 * 
 * Features:
 * - Standard and weekly option symbol parsing
 * - Ticker, strike, expiration extraction
 * - Covered call position analysis
 * - Cash-secured put opportunity identification
 * - Data validation and normalization
 */

export interface ParsedPositionData {
  ticker: string;
  optionType?: 'CALL' | 'PUT';
  strike?: number;
  expiration?: string;
  expirationDate?: Date;
  daysToExpiration?: number;
  isOption: boolean;
  originalSymbol: string;
  confidence: 'high' | 'medium' | 'low';
  errors: string[];
}

export interface WheelOpportunityFromPosition {
  id: string;
  ticker: string;
  strategy: 'covered_call' | 'cash_secured_put' | 'full_wheel';
  confidence: 'high' | 'medium' | 'low';
  description: string;
  prefilledData: {
    ticker: string;
    strategyType: string;
    strikePrice?: number;
    expirationDate?: string;
    contractCount?: number;
    premium?: number;
    positionSize?: number;
    notes?: string;
  };
  sourcePositions: any[];
  potentialIncome?: number;
  riskAssessment: {
    level: 'low' | 'medium' | 'high';
    factors: string[];
  };
}

export class PositionParsingService {
  
  /**
   * Parse option symbol to extract key components
   * Supports formats like: AAPL251219C00175000, TSLA240906P00250000
   */
  static parseOptionSymbol(symbol: string): ParsedPositionData {
    const errors: string[] = [];
    let confidence: 'high' | 'medium' | 'low' = 'low';
    
    // Remove any whitespace and convert to uppercase
    const cleanSymbol = symbol.trim().toUpperCase();
    
    // Standard option symbol regex pattern
    // Format: TICKER + YYMMDD + C/P + 00000000 (strike * 1000)
    const optionPattern = /^([A-Z]{1,5})(\d{6})([CP])(\d{8})$/;
    const match = cleanSymbol.match(optionPattern);
    
    if (!match) {
      errors.push(`Unable to parse option symbol: ${symbol}`);
      return {
        ticker: symbol,
        isOption: false,
        originalSymbol: symbol,
        confidence: 'low',
        errors
      };
    }
    
    const [, ticker, dateStr, optionTypeChar, strikeStr] = match;
    
    // Parse date (YYMMDD format)
    const year = 2000 + parseInt(dateStr.substring(0, 2));
    const month = parseInt(dateStr.substring(2, 4));
    const day = parseInt(dateStr.substring(4, 6));
    
    // Validate date
    const expirationDate = new Date(year, month - 1, day);
    if (expirationDate.getFullYear() !== year || 
        expirationDate.getMonth() !== month - 1 || 
        expirationDate.getDate() !== day) {
      errors.push(`Invalid expiration date: ${dateStr}`);
    }
    
    // Parse strike price (divide by 1000)
    const strike = parseInt(strikeStr) / 1000;
    if (strike <= 0 || strike > 99999) {
      errors.push(`Invalid strike price: ${strike}`);
    }
    
    // Option type
    const optionType = optionTypeChar === 'C' ? 'CALL' : 'PUT';
    
    // Calculate days to expiration
    const now = new Date();
    const daysToExpiration = Math.ceil((expirationDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
    
    // Determine confidence based on validation
    if (errors.length === 0) {
      confidence = 'high';
    } else if (errors.length <= 1) {
      confidence = 'medium';
    }
    
    return {
      ticker,
      optionType,
      strike,
      expiration: expirationDate.toISOString().split('T')[0],
      expirationDate,
      daysToExpiration,
      isOption: true,
      originalSymbol: symbol,
      confidence,
      errors
    };
  }
  
  /**
   * Parse stock symbol (simple validation)
   */
  static parseStockSymbol(symbol: string): ParsedPositionData {
    const cleanSymbol = symbol.trim().toUpperCase();
    const errors: string[] = [];
    
    // Basic stock symbol validation (1-5 letters)
    if (!/^[A-Z]{1,5}$/.test(cleanSymbol)) {
      errors.push(`Invalid stock symbol format: ${symbol}`);
    }
    
    return {
      ticker: cleanSymbol,
      isOption: false,
      originalSymbol: symbol,
      confidence: errors.length === 0 ? 'high' : 'low',
      errors
    };
  }
  
  /**
   * Analyze positions to identify wheel opportunities
   */
  static identifyWheelOpportunities(positions: any[]): WheelOpportunityFromPosition[] {
    console.log('🔬 PositionParsingService.identifyWheelOpportunities called with:', {
      positionsCount: positions?.length,
      firstPosition: positions?.[0],
      allPositions: positions
    });

    const opportunities: WheelOpportunityFromPosition[] = [];
    const groupedByTicker: Record<string, any[]> = {};
    
    // Group positions by underlying ticker
    positions.forEach(position => {
      console.log('🔍 Processing position:', position);
      let ticker: string;
      
      // Extract ticker from position - use underlying_symbol first, then parse symbol
      if (position.underlying_symbol) {
        ticker = position.underlying_symbol;
        console.log('📊 Using underlying_symbol:', ticker);
      } else if (position.symbol) {
        // Fallback to parsing the symbol
        const parsed = position.asset_type === 'OPTION' 
          ? this.parseOptionSymbol(position.symbol)
          : this.parseStockSymbol(position.symbol);
        ticker = parsed.ticker;
        console.log('📊 Parsed ticker from symbol:', ticker, 'from symbol:', position.symbol);
      } else {
        console.log('❌ Position missing symbol and underlying_symbol:', position);
        return; // Skip if no symbol
      }
      
      if (!groupedByTicker[ticker]) {
        groupedByTicker[ticker] = [];
      }
      groupedByTicker[ticker].push(position);
    });
    
    console.log('📈 Positions grouped by ticker:', groupedByTicker);
    
    // Analyze each ticker group for wheel opportunities
    Object.entries(groupedByTicker).forEach(([ticker, tickerPositions]) => {
      console.log('🎯 Analyzing ticker:', ticker, 'with positions:', tickerPositions);
      const tickerOpportunities = this.analyzeTickerForOpportunities(ticker, tickerPositions);
      console.log('🎲 Found opportunities for', ticker, ':', tickerOpportunities);
      opportunities.push(...tickerOpportunities);
    });

    console.log('✅ Final opportunities identified:', opportunities);
    
    return opportunities.sort((a, b) => {
      // Sort by confidence and potential income
      const confidenceOrder = { high: 3, medium: 2, low: 1 };
      const confDiff = confidenceOrder[b.confidence] - confidenceOrder[a.confidence];
      if (confDiff !== 0) return confDiff;
      
      return (b.potentialIncome || 0) - (a.potentialIncome || 0);
    });
  }
  
  /**
   * Analyze positions for a specific ticker to find wheel opportunities
   */
  private static analyzeTickerForOpportunities(ticker: string, positions: any[]): WheelOpportunityFromPosition[] {
    const opportunities: WheelOpportunityFromPosition[] = [];
    
    console.log(`🔍 Analyzing ${ticker} positions:`, positions);
    
    // Separate stock and option positions based on asset_type
    const stockPositions = positions.filter(p => p.asset_type === 'EQUITY');
    const optionPositions = positions.filter(p => p.asset_type === 'OPTION');
    
    console.log(`📊 ${ticker} - Stock positions:`, stockPositions.length, 'Option positions:', optionPositions.length);
    
    // Calculate total stock shares (long_quantity - short_quantity)
    const totalShares = stockPositions.reduce((sum, pos) => {
      const netQuantity = (pos.long_quantity || 0) - (pos.short_quantity || 0);
      return sum + netQuantity;
    }, 0);
    
    console.log(`📈 ${ticker} total shares:`, totalShares);
    
    // Analyze option positions for wheel opportunities
    const shortCalls = optionPositions.filter(opt => 
      opt.option_type === 'CALL' && opt.short_quantity > 0
    );
    
    const shortPuts = optionPositions.filter(opt =>
      opt.option_type === 'PUT' && opt.short_quantity > 0
    );
    
    console.log(`🔧 ${ticker} - Short calls:`, shortCalls.length, 'Short puts:', shortPuts.length);
    
    // 1. Covered Call Opportunity (need stock + short call)
    if (totalShares >= 100 && shortCalls.length > 0) {
      shortCalls.forEach(shortCall => {
        const contractsCanCover = Math.floor(totalShares / 100);
        const maxContracts = Math.min(contractsCanCover, shortCall.short_quantity);
        
        console.log(`🎯 Found covered call opportunity for ${ticker}:`, {
          shares: totalShares,
          shortCall: shortCall,
          maxContracts
        });
        
        opportunities.push({
          id: `covered_call_${ticker}_${shortCall.id}`,
          ticker,
          strategy: 'covered_call',
          confidence: 'high',
          description: `Covered call: ${totalShares} shares + short ${shortCall.strike_price} call exp ${shortCall.expiration_date}`,
          prefilledData: {
            ticker,
            strategyType: 'covered_call',
            strikePrice: shortCall.strike_price,
            expirationDate: shortCall.expiration_date.split('T')[0], // Format as YYYY-MM-DD
            contractCount: maxContracts,
            premium: shortCall.average_price || 0,
            notes: `Covered call from existing positions: ${shortCall.symbol}`
          },
          sourcePositions: [shortCall, ...stockPositions],
          potentialIncome: maxContracts * 100 * (shortCall.average_price || 2.50),
          riskAssessment: {
            level: 'low',
            factors: ['Limited upside if called away', 'Keep premium if expires OTM']
          }
        });
      });
    }
    
    // 2. Cash-Secured Put Opportunity
    if (shortPuts.length > 0) {
      shortPuts.forEach(shortPut => {
        console.log(`🎯 Found cash-secured put opportunity for ${ticker}:`, shortPut);
        
        opportunities.push({
          id: `cash_secured_put_${ticker}_${shortPut.id}`,
          ticker,
          strategy: 'cash_secured_put',
          confidence: 'medium',
          description: `Cash-secured put: Short ${shortPut.strike_price} put exp ${shortPut.expiration_date}`,
          prefilledData: {
            ticker,
            strategyType: 'cash_secured_put',
            strikePrice: shortPut.strike_price,
            expirationDate: shortPut.expiration_date.split('T')[0], // Format as YYYY-MM-DD
            contractCount: shortPut.short_quantity,
            premium: shortPut.average_price || 0,
            positionSize: shortPut.strike_price * shortPut.short_quantity * 100, // Cash requirement
            notes: `Cash-secured put from existing position: ${shortPut.symbol}`
          },
          sourcePositions: [shortPut],
          potentialIncome: shortPut.short_quantity * 100 * (shortPut.average_price || 2.00),
          riskAssessment: {
            level: 'medium',
            factors: ['Obligation to buy shares at strike', 'Keep premium if expires OTM']
          }
        });
      });
    }
    
    // 3. Full Wheel Opportunity (stock + short call + recommend next put)
    if (totalShares >= 100 && shortCalls.length > 0) {
      const shortCall = shortCalls[0];
      
      console.log(`🎯 Found full wheel opportunity for ${ticker}:`, {
        shares: totalShares,
        shortCall: shortCall
      });
      
      opportunities.push({
        id: `full_wheel_${ticker}_${shortCall.id}`,
        ticker,
        strategy: 'full_wheel',
        confidence: 'high',
        description: `Active wheel: ${totalShares} shares + ${shortCall.strike_price} call, ready for put side`,
        prefilledData: {
          ticker,
          strategyType: 'full_wheel',
          strikePrice: shortCall.strike_price * 0.95, // Suggest put 5% below current call strike
          expirationDate: shortCall.expiration_date.split('T')[0],
          contractCount: Math.floor(totalShares / 100),
          notes: `Full wheel strategy - call side active, put side ready`
        },
        sourcePositions: [shortCall, ...stockPositions],
        potentialIncome: (shortCall.average_price || 2.50) * 100 * Math.floor(totalShares / 100),
        riskAssessment: {
          level: 'low',
          factors: ['Generate income on both sides', 'Requires active management']
        }
      });
    }
    
    console.log(`✅ Generated ${opportunities.length} opportunities for ${ticker}`);
    return opportunities;
  }
        sourcePositions: [shortPut],
        potentialIncome: Math.abs(shortPut.quantity || 1) * 100 * 3.00, // Estimate $3.00 premium
        riskAssessment: {
          level: 'medium',
          factors: ['Obligation to buy at strike', 'Keep premium if expires OTM']
        }
      });
    }
    
    // 3. Full Wheel Opportunity
    if (totalShares >= 100 && shortCalls.length > 0 && shortPuts.length > 0) {
      opportunities.push({
        id: `full_wheel_${ticker}_${Date.now()}`,
        ticker,
        strategy: 'full_wheel',
        confidence: 'high',
        description: `Full wheel strategy with stocks, calls, and puts`,
        prefilledData: {
          ticker,
          strategyType: 'full_wheel',
          strikePrice: shortCalls[0].parsed.strike,
          expirationDate: shortCalls[0].parsed.expiration,
          contractCount: Math.abs(shortCalls[0].quantity || 1),
          notes: `Full wheel from existing positions`
        },
        sourcePositions: [...stockPositions, ...shortCalls, ...shortPuts],
        potentialIncome: (Math.abs(shortCalls[0].quantity || 1) + Math.abs(shortPuts[0].quantity || 1)) * 100 * 2.75,
        riskAssessment: {
          level: 'medium',
          factors: ['Complex strategy', 'Multiple moving parts', 'Higher income potential']
        }
      });
    }
    
    // 4. Naked Stock Opportunity (for stocks without options)
    if (totalShares >= 100 && optionPositions.length === 0) {
      opportunities.push({
        id: `naked_stock_${ticker}_${Date.now()}`,
        ticker,
        strategy: 'covered_call',
        confidence: 'medium',
        description: `Ready for covered call strategy with ${totalShares} shares`,
        prefilledData: {
          ticker,
          strategyType: 'covered_call',
          contractCount: Math.floor(totalShares / 100),
          notes: `Start covered call strategy with existing ${totalShares} shares`
        },
        sourcePositions: stockPositions,
        potentialIncome: Math.floor(totalShares / 100) * 100 * 2.00, // Estimate $2.00 premium
        riskAssessment: {
          level: 'low',
          factors: ['Conservative income strategy', 'Upside limited to strike + premium']
        }
      });
    }
    
    return opportunities;
  }
  
  /**
   * Validate and clean parsed position data
   */
  static validateParsedData(data: ParsedPositionData): ParsedPositionData {
    const errors = [...data.errors];
    
    // Additional validations
    if (data.isOption) {
      if (!data.strike || data.strike <= 0) {
        errors.push('Invalid or missing strike price');
      }
      
      if (!data.expiration) {
        errors.push('Invalid or missing expiration date');
      }
      
      if (data.daysToExpiration && data.daysToExpiration < 0) {
        errors.push('Option has already expired');
      }
      
      if (data.daysToExpiration && data.daysToExpiration > 1000) {
        errors.push('Option expiration too far in future');
      }
    }
    
    // Update confidence based on validation
    let confidence = data.confidence;
    if (errors.length > data.errors.length) {
      confidence = errors.length <= 1 ? 'medium' : 'low';
    }
    
    return {
      ...data,
      errors,
      confidence
    };
  }
  
  /**
   * Format expiration date for display
   */
  static formatExpirationDate(date: string | Date): string {
    const dateObj = typeof date === 'string' ? new Date(date) : date;
    return dateObj.toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
      year: 'numeric'
    });
  }
  
  /**
   * Calculate premium estimate based on position data
   */
  static estimatePremium(parsedData: ParsedPositionData): number {
    // Simple premium estimation logic
    // In production, this would use real market data
    
    if (!parsedData.isOption || !parsedData.strike) {
      return 0;
    }
    
    const basePrice = parsedData.strike * 0.02; // 2% of strike as base
    const timeValue = parsedData.daysToExpiration ? Math.max(0.1, parsedData.daysToExpiration / 365) : 0.1;
    
    return Math.round((basePrice * timeValue) * 100) / 100; // Round to cents
  }
}
